{"version":3,"sources":["webpack://LIB/webpack/bootstrap","webpack://LIB/./src/wait.ts","webpack://LIB/./src/compressor.ts","webpack://LIB/./src/decompressor.ts","webpack://LIB/./src/async-lz-string.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","wait","Promise","resolve","setTimeout","REV","writeValueToData","context","bitsToWrite","bitsPerChar","getCharFromInt","dataPosition","dataVal","data","push","numNibbles","ret","reverseBits","writeWToDataVal","dictionaryToCreate","has","w","charCodeAt","CompressorImpl","numBits","enlargeIn","Math","pow","delete","dictionary","loopIteration","uncompressed","ii","context_c","charAt","set","dictSize","context_wc","this","String","compress","Map","length","join","decompress","resetValue","getNextValue","bits","dataIndex","entry","maxPower","power","resb","result","fromCharCode","iteration","compressor","decompressor","compressToUTF16","input","a","decompressFromUTF16","compressed","index"],"mappings":"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","file":"async-lz-string.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","\r\nexport async function wait() {\r\n    return new Promise((resolve) => {\r\n        setTimeout(resolve, 0);\r\n    });\r\n}\r\n","import { wait } from \"./wait\";\r\n\r\nconst REV = [\r\n    0x0,\r\n    0x8,\r\n    0x4,\r\n    0xc,\r\n    0x2,\r\n    0xa,\r\n    0x6,\r\n    0xe,\r\n    0x1,\r\n    0x9,\r\n    0x5,\r\n    0xd,\r\n    0x3,\r\n    0xb,\r\n    0x7,\r\n    0xf,\r\n];\r\n\r\nfunction reverseBits(n: number, numNibbles: number) {\r\n    let ret = 0;\r\n\r\n    for (let i = 0; i < numNibbles; ++i) {\r\n        ret <<= 4;\r\n        ret |= REV[n & 0xF];\r\n        n >>= 4;\r\n    }\r\n\r\n    return ret;\r\n}\r\n\r\nexport interface ICompressor {\r\n    compress(uncompressed: string, bitsPerChar: number, getCharFromInt: (a: number) => string);\r\n}\r\n\r\ninterface ICompressorContext {\r\n    // return value\r\n    data: string[];\r\n    // which bit in dataVal we should write next\r\n    dataPosition: number;\r\n\r\n    // value that will be added to data when dataPosition > numBits - 1\r\n    dataVal: number;\r\n\r\n    dictionary: Map<string, number>;\r\n    dictionaryToCreate: Map<string, boolean>;\r\n    dictSize: number;\r\n\r\n    enlargeIn: number;\r\n\r\n    numBits: number;\r\n\r\n    // Current string context\r\n    w: string;\r\n}\r\n\r\nexport class CompressorImpl implements ICompressor {\r\n    private static writeValueToData(context: ICompressorContext, value: number, bitsToWrite: number, bitsPerChar: number, getCharFromInt: (a: number) => string) {\r\n        if (bitsToWrite % 4 !== 0 || context.dataPosition + bitsToWrite > bitsPerChar - 1) {\r\n            for (let i = 0; i < bitsToWrite; i++) {\r\n                context.dataVal = (context.dataVal << 1) | (value & 1);\r\n                if (context.dataPosition == bitsPerChar - 1) {\r\n                    context.dataPosition = 0;\r\n                    context.data.push(getCharFromInt(context.dataVal));\r\n                    context.dataVal = 0;\r\n                } else {\r\n                    context.dataPosition++;\r\n                }\r\n                value >>= 1;\r\n            }\r\n        } else {\r\n            // Fast + simple path for case where iterations is divisible by 4 and we don't spill into a new character\r\n            context.dataVal <<= bitsToWrite;\r\n            context.dataVal |= reverseBits(value, bitsToWrite / 4);\r\n            context.dataPosition += bitsToWrite;\r\n        }\r\n    }\r\n\r\n    private static writeWToDataVal(context: ICompressorContext, bitsPerChar: number, getCharFromInt: (a: number) => string) {\r\n        if (context.dictionaryToCreate.has(context.w)) {\r\n            if (context.w.charCodeAt(0) < 256) {\r\n                CompressorImpl.writeValueToData(context, 0, context.numBits, bitsPerChar, getCharFromInt);\r\n\r\n                CompressorImpl.writeValueToData(context, context.w.charCodeAt(0), 8, bitsPerChar, getCharFromInt);\r\n            } else {\r\n                CompressorImpl.writeValueToData(context, 1, context.numBits, bitsPerChar, getCharFromInt);\r\n\r\n                CompressorImpl.writeValueToData(context, context.w.charCodeAt(0), 16, bitsPerChar, getCharFromInt);\r\n            }\r\n            context.enlargeIn--;\r\n            if (context.enlargeIn == 0) {\r\n                context.enlargeIn = Math.pow(2, context.numBits);\r\n                context.numBits++;\r\n            }\r\n            context.dictionaryToCreate.delete(context.w);\r\n        } else {\r\n            CompressorImpl.writeValueToData(context, context.dictionary.get(context.w), context.numBits, bitsPerChar, getCharFromInt);\r\n        }\r\n        context.enlargeIn--;\r\n        if (context.enlargeIn == 0) {\r\n            context.enlargeIn = Math.pow(2, context.numBits);\r\n            context.numBits++;\r\n        }\r\n    }\r\n\r\n    private static loopIteration(uncompressed: string, ii: number, bitsPerChar: number, getCharFromInt: (a: number) => string, context: ICompressorContext) {\r\n        const context_c = uncompressed.charAt(ii);\r\n        if (!context.dictionary.has(context_c)) {\r\n            context.dictionary.set(context_c, context.dictSize++);\r\n            context.dictionaryToCreate.set(context_c, true)\r\n        }\r\n\r\n        const context_wc = context.w + context_c;\r\n\r\n        if (context.dictionary.has(context_wc)) {\r\n            // we have seen the string contained in context_wc before. Update context so on next iteration we will continue building on this string.\r\n            context.w = context_wc;\r\n        } else {\r\n            this.writeWToDataVal(context, bitsPerChar, getCharFromInt);\r\n            context.dictionary.set(context_wc, context.dictSize++);\r\n            context.w = String(context_c);\r\n        }\r\n    }\r\n\r\n    public compress(uncompressed: string, bitsPerChar: number, getCharFromInt: (a: number) => string): Promise<string> {\r\n        return new Promise(async (resolve) => {\r\n            if (uncompressed == null) {\r\n                resolve(\"\");\r\n                return;\r\n            }\r\n\r\n            let context: ICompressorContext = {\r\n                data: [],\r\n                dataPosition: 0,\r\n                dataVal: 0,\r\n                dictionary: new Map<string, number>(),\r\n                dictionaryToCreate: new Map<string, boolean>(),\r\n                dictSize: 3,\r\n                enlargeIn: 2,\r\n                numBits: 2,\r\n                w: \"\",\r\n            };\r\n\r\n            for (let ii = 0; ii < uncompressed.length; ii += 1) {\r\n                CompressorImpl.loopIteration(uncompressed, ii, bitsPerChar, getCharFromInt, context);\r\n                if (ii % 10000 === 0) {\r\n                    await wait();\r\n                }\r\n            }\r\n\r\n            // Output the code for w.\r\n            if (context.w !== \"\") {\r\n                CompressorImpl.writeWToDataVal(context, bitsPerChar, getCharFromInt);\r\n            }\r\n\r\n            CompressorImpl.writeValueToData(context, 2, context.numBits, bitsPerChar, getCharFromInt);\r\n\r\n            context.dataVal <<= bitsPerChar - context.dataPosition;\r\n            context.data.push(getCharFromInt(context.dataVal));\r\n\r\n            resolve(context.data.join(''));\r\n        });\r\n    }\r\n}\r\n","import { wait } from \"./wait\";\r\n\r\nexport interface IDecompressor {\r\n    decompress(length: number, resetValue: number, getNextValue: (a: number) => number);\r\n}\r\n\r\ninterface IDecompressionContext {\r\n    bits: number;\r\n\r\n    c: string | number;\r\n\r\n    dataIndex: number;\r\n    dataPosition: number;\r\n    dataVal: number;\r\n\r\n    dictionary: Map<number, number>;\r\n    dictSize: number;\r\n\r\n    enlargeIn: number;\r\n\r\n    entry: string | number;\r\n\r\n    maxPower: number;\r\n\r\n    numBits: number;\r\n\r\n    power: number;\r\n\r\n    resb: number;\r\n\r\n    result: string[];\r\n\r\n    w: string;\r\n}\r\n\r\nexport class DecompressorImpl implements IDecompressor {\r\n    public decompress(length: number, resetValue: number, getNextValue: (a: number) => number): Promise<string> {\r\n        return new Promise(async (resolve) => {\r\n            let context: IDecompressionContext = {\r\n                bits: 0,\r\n\r\n                c: null,\r\n\r\n                dataIndex: 1,\r\n                dataPosition: resetValue,\r\n                dataVal: getNextValue(0),\r\n\r\n                dictionary: new Map<number, number>(),\r\n                dictSize: 4,\r\n\r\n                enlargeIn: 4,\r\n\r\n                entry: \"\",\r\n\r\n                maxPower: Math.pow(2, 2),\r\n\r\n                numBits: 3,\r\n\r\n                power: 1,\r\n\r\n                resb: null,\r\n\r\n                result: [],\r\n\r\n                w: null\r\n            };\r\n\r\n            for (let i = 0; i < 3; i += 1) {\r\n                context.dictionary.set(i, i);\r\n            }\r\n\r\n            while (context.power != context.maxPower) {\r\n                context.resb = context.dataVal & context.dataPosition;\r\n                context.dataPosition >>= 1;\r\n                if (context.dataPosition == 0) {\r\n                    context.dataPosition = resetValue;\r\n                    context.dataVal = getNextValue(context.dataIndex++);\r\n                }\r\n                context.bits |= (context.resb > 0 ? 1 : 0) * context.power;\r\n                context.power <<= 1;\r\n            }\r\n\r\n            const next = context.bits;\r\n            switch (next) {\r\n                case 0:\r\n                    context.bits = 0;\r\n                    context.maxPower = Math.pow(2, 8);\r\n                    context.power = 1;\r\n                    while (context.power != context.maxPower) {\r\n                        context.resb = context.dataVal & context.dataPosition;\r\n                        context.dataPosition >>= 1;\r\n                        if (context.dataPosition == 0) {\r\n                            context.dataPosition = resetValue;\r\n                            context.dataVal = getNextValue(context.dataIndex++);\r\n                        }\r\n                        context.bits |= (context.resb > 0 ? 1 : 0) * context.power;\r\n                        context.power <<= 1;\r\n                    }\r\n                    context.c = String.fromCharCode(context.bits);\r\n                    break;\r\n                case 1:\r\n                    context.bits = 0;\r\n                    context.maxPower = Math.pow(2, 16);\r\n                    context.power = 1;\r\n                    while (context.power !== context.maxPower) {\r\n                        context.resb = context.dataVal & context.dataPosition;\r\n                        context.dataPosition >>= 1;\r\n                        if (context.dataPosition === 0) {\r\n                            context.dataPosition = resetValue;\r\n                            context.dataVal = getNextValue(context.dataIndex++);\r\n                        }\r\n                        context.bits |= (context.resb > 0 ? 1 : 0) * context.power;\r\n                        context.power <<= 1;\r\n                    }\r\n                    context.c = String.fromCharCode(context.bits);\r\n                    break;\r\n                case 2:\r\n                    resolve(\"\");\r\n                    return;\r\n            }\r\n            context.dictionary[3] = context.c;\r\n            context.w = context.c as string;\r\n            context.result.push(context.c as string);\r\n            let iteration = 1;\r\n            while (true) {\r\n                if (iteration % 20000 === 0) {\r\n                    await wait();\r\n                }\r\n                if (context.dataIndex > length) {\r\n                    resolve(\"\");\r\n                    return;\r\n                }\r\n\r\n                context.bits = 0;\r\n                context.maxPower = Math.pow(2, context.numBits);\r\n                context.power = 1;\r\n                while (context.power != context.maxPower) {\r\n                    context.resb = context.dataVal & context.dataPosition;\r\n                    context.dataPosition >>= 1;\r\n                    if (context.dataPosition == 0) {\r\n                        context.dataPosition = resetValue;\r\n                        context.dataVal = getNextValue(context.dataIndex++);\r\n                    }\r\n                    context.bits |= (context.resb > 0 ? 1 : 0) * context.power;\r\n                    context.power <<= 1;\r\n                }\r\n                switch (context.c = context.bits) {\r\n                    case 0:\r\n                        context.bits = 0;\r\n                        context.maxPower = Math.pow(2, 8);\r\n                        context.power = 1;\r\n                        while (context.power !== context.maxPower) {\r\n                            context.resb = context.dataVal & context.dataPosition;\r\n                            context.dataPosition >>= 1;\r\n                            if (context.dataPosition == 0) {\r\n                                context.dataPosition = resetValue;\r\n                                context.dataVal = getNextValue(context.dataIndex++);\r\n                            }\r\n                            context.bits |= (context.resb > 0 ? 1 : 0) * context.power;\r\n                            context.power <<= 1;\r\n                        }\r\n\r\n                        context.dictionary[context.dictSize++] = String.fromCharCode(context.bits);\r\n                        context.c = context.dictSize - 1;\r\n                        context.enlargeIn--;\r\n                        break;\r\n                    case 1:\r\n                        context.bits = 0;\r\n                        context.maxPower = Math.pow(2, 16);\r\n                        context.power = 1;\r\n                        while (context.power !== context.maxPower) {\r\n                            context.resb = context.dataVal & context.dataPosition;\r\n                            context.dataPosition >>= 1;\r\n                            if (context.dataPosition == 0) {\r\n                                context.dataPosition = resetValue;\r\n                                context.dataVal = getNextValue(context.dataIndex++);\r\n                            }\r\n                            context.bits |= (context.resb > 0 ? 1 : 0) * context.power;\r\n                            context.power <<= 1;\r\n                        }\r\n                        context.dictionary[context.dictSize++] = String.fromCharCode(context.bits);\r\n                        context.c = context.dictSize - 1;\r\n                        context.enlargeIn--;\r\n                        break;\r\n                    case 2:\r\n                        resolve(context.result.join(''));\r\n                        return;\r\n                }\r\n\r\n                if (context.enlargeIn == 0) {\r\n                    context.enlargeIn = Math.pow(2, context.numBits);\r\n                    context.numBits++;\r\n                }\r\n\r\n                if (context.dictionary[context.c]) {\r\n                    context.entry = context.dictionary[context.c];\r\n                } else {\r\n                    if (context.c === context.dictSize) {\r\n                        context.entry = context.w + context.w.charAt(0);\r\n                    } else {\r\n                        resolve(null);\r\n                        return;\r\n                    }\r\n                }\r\n                context.result.push(context.entry as string);\r\n\r\n                // Add w+entry[0] to the dictionary.\r\n                context.dictionary[context.dictSize++] = context.w + (context.entry as string).charAt(0);\r\n                context.enlargeIn--;\r\n\r\n                context.w = context.entry as string;\r\n\r\n                if (context.enlargeIn == 0) {\r\n                    context.enlargeIn = Math.pow(2, context.numBits);\r\n                    context.numBits++;\r\n                }\r\n\r\n                iteration++;\r\n            }\r\n        });\r\n    }\r\n}\r\n","import { ICompressor, CompressorImpl } from \"./compressor\";\r\nimport { IDecompressor, DecompressorImpl } from \"./decompressor\";\r\n\r\nconst compressor: ICompressor = new CompressorImpl();\r\nconst decompressor: IDecompressor = new DecompressorImpl();\r\n\r\nexport async function compressToUTF16(input: string) {\r\n  if (input === null) {\r\n    return \"\";\r\n  }\r\n  const compressResult = await compressor.compress(\r\n    input,\r\n    15,\r\n    function (a: number) {\r\n      return String.fromCharCode(a + 32);\r\n    }\r\n  );\r\n  return compressResult + \" \";\r\n}\r\n\r\nexport async function decompressFromUTF16(compressed: string) {\r\n  if (compressed === null) {\r\n    return \"\";\r\n  }\r\n  if (compressed === \"\") {\r\n    return null;\r\n  }\r\n  return await decompressor.decompress(\r\n    compressed.length,\r\n    16384,\r\n    function (index: number) {\r\n      return compressed.charCodeAt(index) - 32;\r\n    }\r\n  );\r\n}\r\n"],"sourceRoot":""}